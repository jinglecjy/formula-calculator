{"version":3,"names":[],"mappings":"","sources":["calculator.js"],"sourcesContent":["/**\n * 描述：带括号的四则运算\n * 作者：caijieying\n */\nimport { Stack } from \"./dataStructure\"\nimport _ from \"lodash\"\n\nfunction isBracket(c) {\n  return c === \"(\" || c === \")\"\n}\nfunction isOper(c) {\n  return c === \"(\" || c === \")\" || c === \"+\" || c === \"-\" || c === \"*\" || c === \"/\"\n}\nfunction getPriority(oper) {\n  switch (oper) {\n    case \"+\":\n    case \"-\":\n      return 0\n    case \"*\":\n    case \"/\":\n      return 1\n    case \"(\":\n    case \")\":\n      return -1\n    default:\n      return -2\n  }\n}\nfunction handlerSymbol(c, postfixHelper, postfix) {\n  if (postfixHelper.empty()) {\n    postfixHelper.push(c)\n    return\n  }\n  if (isBracket(c)) {\n    if (c === \"(\") postfixHelper.push(c)\n    else {\n      // 弹出所有元素直到遇到左括号\n      while (postfixHelper.top() !== \"(\") {\n        let ch = postfixHelper.top()\n        postfix.push(ch)\n        postfixHelper.pop()\n      }\n      // 当遇到左括号时，弹出但不加入postfix(后缀表达式中）\n      postfixHelper.pop()\n    }\n  } else {\n    // 如果不是括号\n    // 取出栈顶元素，与当前符号进行优先性比较\n    let sym = postfixHelper.top()\n    // 比较两符号的优先性\n    if (getPriority(c) <= getPriority(sym)) {\n      // 如果c的优先性比栈顶符号小或等于，弹出栈顶元素\n      postfixHelper.pop()\n      // 并将其压入postfix（后缀表达式）中\n      postfix.push(sym)\n      // 递归调用handler,比较当前符号c与下一个栈顶符号的优先性\n      handler(c, postfixHelper, postfix)\n    } else {\n      // 如果c比栈顶符号优先级大，那将c压入coll2(操作符栈）中\n      postfixHelper.push(c)\n    }\n  }\n}\n\n/**\n * 中缀表达式公式转换为后缀表达式\n * \n * @param {string} infix \n * @param {arr} postfix \n */\nfunction infixToPostFix(infix, postfix) {\n  let postfixHelper = Stack()\n  for(let i=0; i<infix.length; i++) {\n    let c = infix[i]\n    if (!isOper(c)) { // 处理操作数\n      let operands = \"\"\n      while (i<infix.length && !isOper(infix[i])) {\n        operands += infix[i++]\n      }\n      postfix.push(operands)\n      i--;\n    } else {// 处理操作符做出处理\n      handlerSymbol(c, postfixHelper, postfix)\n    }\n  }\n  // 如果输入结束，将栈内元素全部弹出，加入后缀表达式中\n  while (!postfixHelper.empty()) {\n    let c = postfixHelper.top()\n    postfix.push(c)\n    postfixHelper.pop()\n  }\n}\n\n// 计算后缀表达式\nfunction calcPostFix(postfix, data) {\n  let helperStack = Stack()\n  for (let i=0; i<postfix.length; i++) {\n    let c = postfix[i]\n\n    // 如果是操作数，压入栈中\n    if (!isOper(c)) {\n      let op = formatData(c, data)\n      helperStack.push(op)\n    } else {\n      // 如果是操作符，从栈中弹出元素进行计算\n      let op1 = helperStack.top()\n      helperStack.pop()\n      let op2 = helperStack.top()\n      helperStack.pop()\n      if (op1 === null || op2 === null) {\n        helperStack.push(null)\n      } else {\n\n        switch (c) {\n          case \"+\":\n            helperStack.push(op2 + op1)\n            break\n          case \"-\":\n            helperStack.push(op2 - op1)\n            break\n          case \"*\":\n            helperStack.push(op2 * op1)\n            break\n          case \"/\":\n            helperStack.push(op2 / op1) // 注意是op2(op)op1而不是op1(op)op2\n            break\n        }\n      }\n    }\n  }\n  return helperStack.top()\n}\n\n/**\n * 处理自定义公式操作数\n * 对于字符串：根据规则获取数据库字段\n * 对于数字：直接返回\n * @param {} param0 \n */\nfunction formatData(opRaw, data) {\n  let op = _.trim(opRaw)\n  if (_.isFinite(_.toNumber(op))) {\n    return _.toNumber(op)\n  } else if (op.search(/(\\S*)_(\\S*)/g) >= 0) {\n    let obj = RegExp.$1\n    let key = RegExp.$2\n    if (data.hasOwnProperty(obj)) {\n      return data[obj][key]\n    } else {\n      return null\n    }\n  }\n}\n\n/**\n *\n * @param formula 公式\n * @param data    数据对象\n */\nexport function calcFormula({ formula, data }) {\n  let infix = formula.replace(/\\s/g, '') // 去除公式空格\n  let postfix = []\n\n  // 1. 中缀表达式转后缀表达式\n  infixToPostFix(infix, postfix)\n\n  // 2. 计算后缀表达式\n  const res = calcPostFix(postfix, data)\n  return res\n}\n"],"file":"calculator.js"}